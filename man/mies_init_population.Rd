% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mies_methods.R
\name{mies_init_population}
\alias{mies_init_population}
\title{Initialize MIES Optimization}
\usage{
mies_init_population(
  inst,
  mu,
  initializer = generate_design_random,
  fidelity_schedule = NULL,
  budget_id = NULL,
  additional_component_sampler = NULL
)
}
\arguments{
\item{inst}{(\code{\link[bbotk:OptimInstance]{OptimInstance}})\cr
Optimization instance to evaluate.}

\item{mu}{(\code{integer(1)})\cr
Population target size.}

\item{initializer}{(\code{function})\cr
Function that generates a \code{\link[paradox:Design]{Design}} object, with arguments \code{param_set} and \code{n}, functioning like \code{\link[paradox:generate_design_random]{paradox::generate_design_random}}
or \code{\link[paradox:generate_design_lhs]{paradox::generate_design_lhs}}. Note that \code{\link[paradox:generate_design_grid]{paradox::generate_design_grid}} can not be used and must be wrapped with
a custom function that ensures that only \code{n} individuals are produced. The generated design must correspond to the \code{inst}'s \verb{$search_space}; for
components that are not in the objective's search space, the \code{additional_component_sampler} is used.}

\item{fidelity_schedule}{(\code{data.frame} | \code{NULL})\cr
\code{data.frame} with three columns \code{"generation"}, \code{"budget_new"}, \code{"budget_survivors"}, in that order. \code{"budget_new"} and \code{"budget_survivors"}
are atomic columns assigned to the \code{budget_id} component of \code{offspring}; which one is chosen depends on \code{survivor_budget}.
\code{"generation"} is an integer valued column, indicating the first generation at which a row is valid. At least one row with
\code{generation == 1} must be present.\cr
This value may be \code{NULL} if no multi-fidelity optimization is performed (the default).\cr
Note that the multifidelity functionality is experimental and the UI may change in the future.}

\item{budget_id}{(\code{character(1)} | \code{NULL})\cr
Budget component that is set to the value found in \code{fidelity_schedule} when doing multi-fidelity optimization. Should be \code{NULL}
when and only when \code{fidelity_schedule} is \code{NULL}.}

\item{additional_component_sampler}{(\code{\link[paradox:Sampler]{Sampler}} | \code{NULL})\cr
\code{\link[paradox:Sampler]{Sampler}} for components of individuals that are not part of \code{inst}'s \verb{$search_space}. These components
are never used for performance evaluation, but they may be useful for self-adaptive \code{\link{OperatorCombination}}s. See the description
of \code{\link[=mies_prime_operators]{mies_prime_operators()}} on how operators need to be primed to respect additional components.\cr
It is possible that \code{additional_component_sampler} is used for \emph{more} rows than \code{initializer}, which happens
when the \code{inst}'s \verb{$archive} contains prior evaluations that are alive, but does not contain columns pertaining to additional columns,
or contains \emph{all} these columns but there are rows that are \code{NA} valued. If only \emph{some} of the columns are present, or if all these columns
are present but there are rows that are only \code{NA} valued for some columns, then an error is thrown.\cr
Default is \code{NULL}: no additional components.}
}
\value{
\link{invisible} \code{\link[bbotk:OptimInstance]{OptimInstance}}: the input
instance, modified by-reference.
}
\description{
Set up an \code{\link[bbotk:OptimInstance]{OptimInstance}} for MIES optimization.
This adds the \code{dob} and \code{eol} columns to the instance's archive, and makes sure there are at least \code{mu} survivors
(i.e. entries with \code{eol} set to \code{NA}) present. If there are already \verb{>= mu} prior evaluations present, then the last
\code{mu} of these remain alive (the other's \code{eol} set to 0); otherwise, up to \code{mu} new randomly sampled configurations
are evaluated and added to the archive and have \code{eol} set to \code{NA}.
}
\examples{
library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective <- ObjectiveRFun$new(
  fun = function(xs) {
    z <- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi <- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

mies_init_population(inst = oi, mu = 3)

# 3 evaluations, archive contains 'dob' and 'eol'
oi$archive

###
# Advanced demo, making use of additional components and fidelity_schedule
# Note that the multifidelity functionality is experimental and the UI may
# change in the future.
##

# Get a new OptimInstance
oi <- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

mies_init_population(inst = oi, mu = 3,
  fidelity_schedule = data.frame(
    generation = c(1, 3),
    budget_new = c(1, 2),
    budget_survivors = c(2, 3)
  ), budget_id = "y",
  additional_component_sampler = Sampler1DRfun$new(
    param = ParamDbl$new("additional", -1, 1), rfun = function(n) rep(-1, n)
  )
)

# 3 evaluations. We also have 'additional', sampled from rfun (always -1),
# which is ignored by the objective. Besides, we have "y", which is 2,
# according to the fidelity_schedule: `budget_survivors` of `generation` 1.
oi$archive

}
\seealso{
Other mies building blocks: 
\code{\link{mies_evaluate_offspring}()},
\code{\link{mies_generate_offspring}()},
\code{\link{mies_get_fitnesses}()},
\code{\link{mies_select_from_archive}()},
\code{\link{mies_step_fidelity}()},
\code{\link{mies_survival_comma}()},
\code{\link{mies_survival_plus}()}
}
\concept{mies building blocks}

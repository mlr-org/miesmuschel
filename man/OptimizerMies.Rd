% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/OptimizerMies.R, R/TunerMies.R
\name{OptimizerMies}
\alias{OptimizerMies}
\alias{TunerMies}
\title{Mixed Integer Evolutionary Strategies Optimizer}
\description{
Perform optimization using evolutionary strategies. \code{OptimizerMies} and \code{TunerMies} implement a standard ES optimization
algorithm, performing initialization first, followed by a loop of performance evaluation, survival selection, parent selection, mutation, and
recombination. Currently two different survival modes ("comma" and "plus") are supported. Multi-fidelity optimization, similar
to the "rolling-tide" algorithm described in Fieldsend (2014). The modular design and reliance on
\code{\link{MiesOperator}} objects to perform central parts of the optimization algorithm makes this \code{\link[bbotk:Optimizer]{Optimizer}}
highly flexible and configurable. In combination with \code{\link{OperatorCombination}} mutators and recombinators, an algorithm
as presented in Li (2013) can easily be implemented.

\code{OptimizerMies} implements a standard evolutionary strategies loop:
\enumerate{
\item Prime operators, using \code{mies_prime_operators()}
\item Initialize and evaluate population, using \code{mies_init_population()}
\item Optionally, evaluate survivors with higher fidelity if the multi-fidelity functionality is being used
\item Generate offspring by selecting parents, recombining and mutating them, using \code{mies_generate_offspring()}
\item Evaluate performance, using \code{mies_evaluate_offspring()}
\item Select survivors, using either \code{mies_survival_plus()} or \code{mies_survival_comma()}, depending on the \code{survival_strategy} configuration parameter
\item Jump to 3.
}
}
\section{Terminating}{

As with all optimizers, \code{\link[bbotk:Terminator]{Terminator}}s are used to end optimization after a specific number of evaluations were performed,
time elapsed, or other conditions are satisfied. Of particular interest is \code{\link{TerminatorGenerations}}, which terminates after a number
of generations were evaluated in \code{OptimizerMies}. The initial population counts as generation 1, its offspring as generation 2 etc.;
fidelity refinements are always included in their generation, \code{\link{TerminatorGenerations}} avoids terminating right before they are evaluated.
Other terminators may, however, end the optimization process at any time.
}

\section{Multi-Fidelity}{

\code{miesmuschel} provides a simple multi-fidelity optimization mechanism that allows increasing fidelity both by generation
number and survival status. When \code{multi_fidelity} is \code{TRUE}, then one search space component of the \code{\link[bbotk:OptimInstance]{OptimInstance}}
must have the \code{"budget"} tag, which is then optimized as the "budget" component. This means that the value of this component is
determined by the \code{fidelity_schedule} configuration parameter, which must contain a \code{data.frame} with columns \code{"generation"}, \code{"budget_new"} and
\code{"budget_survivors"}. The budget component's value of newly sampled individuals is set to the \code{"budget_new"} entry in the generation's row,
and surviving individuals are evaluated again with the budget set to the \code{"budget_survivors"} value (unless they are the same). At the
end of a generation, if the \code{"budget_survivors"} value changes, all individuals from previous generations are re-evaluated with the
new budget value, unless \code{fidelity_current_gen_only} is set to \code{TRUE} (and unless the budget value decreases and \code{fidelity_monotonic} is \code{TRUE}).
This makes it possible to implement increasing fidelity by generation, and also increasing fidelity for samples that survived a generation.

The \code{fidelity_schedule} configuration parameter's \code{"generation"} column determines which row is currently active. A row becomes active in the
generation that is listed, and becomes inactive whenever a different row becomes active. So e.g. if \code{fidelity_schedule} contains a row
with \code{"generation"} set to 1, and one set to 4, then the first row is active during generations 1, 2, and 3, and the second row
is active for all following generations.

Note that the multifidelity functionality is experimental and the UI may change in the future.
}

\section{Additional Components}{

The search space over which the optimization is performed is fundamentally tied to the \code{\link[bbotk:Objective]{Objective}}, and therefore
to the \code{\link[bbotk:OptimInstance]{OptimInstance}} given to \code{OptimizerMies$optimize()}. However, some advanced Evolutionary Strategy based
algorithms may need to make use of additional search space components that are independent of the particular objective. An example is
self-adaption as implemented in \code{\link{OperatorCombination}}, where one or several components can be used to adjust operator behaviour.
These additional components are supplied to the optimizer through the \code{additional_component_sampler} configuration parameter, which takes
a \code{\link[paradox:Sampler]{Sampler}} object. This object both has an associated \code{\link[paradox:ParamSet]{ParamSet}} which represents the
additional components that are present, and it provides a method for generating the initial values of these components. The search space
that is seen by the \code{\link{MiesOperator}}s is then the union of the \code{\link{OptimInstance}}'s \code{\link[paradox:ParamSet]{ParamSet}}, and the
\code{\link[paradox:Sampler]{Sampler}}'s \code{\link[paradox:ParamSet]{ParamSet}}.
}

\section{Configuration Parameters}{

\code{OptimizerMies} has the configuration parameters of the \code{mutator}, \code{recombinator}, \code{parent_selector}, \code{survival_selector}, and, if given,
\code{elite_selector} operator given during construction, and prefixed according to the name of the argument (\code{mutator}'s configuration parameters
are prefixed \code{"mutator."} etc.). When using the construction arguments' default values, they are all "proxy" operators: \code{\link{MutatorProxy}},
\code{\link{RecombinatorProxy}} and \code{\link{SelectorProxy}}. This means that the respective configuration parameters become \code{mutator.operation}, \code{recombinator.operation} etc.,
so the operators themselves can be set via configuration parameters in this case.

Further configuration parameters are:
\itemize{
\item \code{lambda} :: \code{integer(1)}\cr
Offspring size: Number of individuals that are created and evaluated anew for each generation. This is equivalent to the
\code{lambda} parameter of \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}, see there for more information. Initialized to 10.
\item \code{mu} :: \code{integer(1)}\cr
Population size: Number of individuals that are sampled in the beginning, and which are selected with each survival step.
This is equivalent to the \code{mu} parameter of \code{\link[=mies_init_population]{mies_init_population()}}, see there for more information. Initialized to 1.
\item \code{survival_strategy} :: \code{character(1)}\cr
May be \code{"plus"}, or, if the \code{elite_selector} construction argument is not \code{NULL}, \code{"comma"}: Choose whether \code{\link[=mies_survival_plus]{mies_survival_plus()}}
or \code{\link[=mies_survival_comma]{mies_survival_comma()}} is used for survival selection. Initialized to \code{"plus"}.
\item \code{n_elite} :: \code{integer(1)}\cr
Only if the \code{elite_selector} construction argument is not \code{NULL}, and only valid when \code{survival_strategy} is \code{"comma"}:
Number of elites, i.e. individuals from the parent generation, to keep during "Comma" survival.
This is equivalent to the \code{n_elite} parameter of \code{\link[=mies_survival_comma]{mies_survival_comma()}}, see there for more information.
\item \code{initializer} :: \code{function}\cr
Function that generates the initial population as a \code{\link[paradox:Design]{Design}} object,
with arguments \code{param_set} and \code{n}, functioning like \code{\link[paradox:generate_design_random]{paradox::generate_design_random}} or \code{\link[paradox:generate_design_lhs]{paradox::generate_design_lhs}}.
This is equivalent to the \code{initializer} parameter of \code{\link[=mies_init_population]{mies_init_population()}}, see there for more information. Initialized to
\code{\link[paradox:generate_design_random]{generate_design_random()}}.
\item \code{additional_component_sampler} :: \code{\link[paradox:Sampler]{Sampler}} | \code{NULL}\cr
Additional components that may be part of individuals as seen by mutation, recombination, and selection \code{\link{MiesOperator}}s, but
that are not part of the search space of the \code{\link[bbotk:OptimInstance]{OptimInstance}} being optimized.
This is equivalent to the \code{additional_component_sampler} parameter of \code{\link[=mies_init_population]{mies_init_population()}}, see there for more information.
Initialized to \code{NULL} (no additional components).
\item \code{fidelity_schedule} :: \code{data.frame}\cr
Only if the \code{multi_fidelity} construction argument is \code{TRUE}:
Table that determines the value of the "budget" component of individuals being evaluated when doing multi-fidelity optimization.
This is equivalent to the \code{fidelity_schedule} parameter of \code{\link[=mies_init_population]{mies_init_population()}}, \code{\link[=mies_evaluate_offspring]{mies_evaluate_offspring()}}, and \code{\link[=mies_step_fidelity]{mies_step_fidelity()}};
see there for more information.\cr
When this configuration parameter is present (i.e. \code{multi_fidelity} is \code{TRUE}), then it is initialized to a \code{data.frame} containing one row
for generation 1, setting budget to 1 for both new and survivor individuals.\cr
Note that the multifidelity functionality is experimental and the UI may change in the future.
\item \code{fidelity_generation_lookahead} :: \code{logical(1)}\cr
Only if the \code{multi_fidelity} construction argument is \code{TRUE}:
Whether to use the \code{"survivor_budget"} of the \emph{next} generation, instead of the \emph{current} generation, when doing fidelity refinement
in \code{\link[=mies_step_fidelity]{mies_step_fidelity()}}.
This is equivalent to the \code{generation_lookahead} parameter of \code{\link[=mies_step_fidelity]{mies_step_fidelity()}}, see there for more information.\cr
When this configuration parameter is present (i.e. \code{multi_fidelity} is \code{TRUE}), then it is initialized to \code{TRUE}.\cr
Note that the multifidelity functionality is experimental and the UI may change in the future.
\item \code{fidelity_current_gen_only} :: \code{logical(1)}\cr
Only if the \code{multi_fidelity} construction argument is \code{TRUE}:
When doing fidelity refinement in \code{\link[=mies_step_fidelity]{mies_step_fidelity()}}, whether to refine all individuals with different budget component,
or only individuals created in the current generation.
This is equivalent to the \code{current_gen_only} parameter of \code{\link[=mies_step_fidelity]{mies_step_fidelity()}}, see there for more information.\cr
When this configuration parameter is present (i.e. \code{multi_fidelity} is \code{TRUE}), then it is initialized to \code{FALSE}.\cr
Note that the multifidelity functionality is experimental and the UI may change in the future.
\item \code{fidelity_monotonic} :: \code{logical(1)}\cr
Only if the \code{multi_fidelity} construction argument is \code{TRUE}:
Whether to only do fidelity refinement in \code{\link[=mies_step_fidelity]{mies_step_fidelity()}} for individuals for which the when budget component value would \emph{increase}.
This is equivalent to the \code{monotonic} parameter of \code{\link[=mies_step_fidelity]{mies_step_fidelity()}}, see there for more information.\cr
When this configuration parameter is present (i.e. \code{multi_fidelity} is \code{TRUE}), then it is initialized to \code{TRUE}.\cr
Note that the multifidelity functionality is experimental and the UI may change in the future.
}
}

\examples{
\donttest{
lgr::threshold("warn")

op.m <- mut("gauss")
op.r <- rec("xounif", p = .3)
op.parent <- sel("random")
op.survival <- sel("best")

#####
# Optimizing a Function
#####

library("bbotk")

# Define the objective to optimize
objective <- ObjectiveRFun$new(
  fun = function(xs) {
    z <- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi <- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

# Create OptimizerMies object
mies_opt <- opt("mies", mutator = op.m, recombinator = op.r,
  parent_selector = op.parent, survival_selector = op.survival,
  mu = 10, lambda = 5)

# mies_opt$optimize performs MIES optimization and returns the optimum
mies_opt$optimize(oi)

#####
# Optimizing a Machine Learning Method
#####

# Note that this is a short example, aiming at clarity and short runtime.
# The settings are not optimal for hyperparameter tuning. The resampling
# in particular should not be "holdout" for small datasets where this gives
# a very noisy estimate of performance.

library("mlr3")
library("mlr3tuning")

# The Learner to optimize
learner = lrn("classif.rpart")

# The hyperparameters to optimize
learner$param_set$values[c("cp", "maxdepth")] = list(to_tune())

# Get a TuningInstance
ti = TuningInstanceSingleCrit$new(
  task = tsk("iris"),
  learner = learner,
  resampling = rsmp("holdout"),
  measure = msr("classif.acc"),
  terminator = trm("gens", generations = 10)
)

# Create TunerMies object
mies_tune <- tnr("mies", mutator = op.m, recombinator = op.r,
  parent_selector = op.parent, survival_selector = op.survival,
  mu = 10, lambda = 5)

# mies_tune$optimize performs MIES optimization and returns the optimum
mies_tune$optimize(ti)
}
}
\references{
Fieldsend, E J, Everson, M R (2014).
\dQuote{The rolling tide evolutionary algorithm: A multiobjective optimizer for noisy optimization problems.}
\emph{IEEE Transactions on Evolutionary Computation}, \bold{19}(1), 103--117.

Li, Rui, Emmerich, TM M, Eggermont, Jeroen, B"ack, Thomas, Sch"utz, Martin, Dijkstra, Jouke, Reiber, HC J (2013).
\dQuote{Mixed integer evolution strategies for parameter optimization.}
\emph{Evolutionary computation}, \bold{21}(1), 29--64.
}
\seealso{
Other optimizers: 
\code{\link{OptimizerSmash}}
}
\concept{optimizers}
\section{Super class}{
\code{\link[bbotk:Optimizer]{bbotk::Optimizer}} -> \code{OptimizerMies}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{mutator}}{(\code{\link{Mutator}})\cr
Mutation operation to perform during \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}.}

\item{\code{recombinator}}{(\code{\link{Recombinator}})\cr
Recombination operation to perform during \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}.}

\item{\code{parent_selector}}{(\code{\link{Selector}})\cr
Parent selection operation to perform during \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}.}

\item{\code{survival_selector}}{(\code{\link{Selector}})\cr
Survival selection operation to use in \code{\link[=mies_survival_plus]{mies_survival_plus()}} or \code{\link[=mies_survival_comma]{mies_survival_comma()}}.}

\item{\code{elite_selector}}{(\code{\link{Selector}} | \code{NULL})\cr
Elite selector used in \code{\link[=mies_survival_comma]{mies_survival_comma()}}.}

\item{\code{param_set}}{(\code{\link[paradox:ParamSet]{ParamSet}})\cr
Configuration parameters of the optimization algorithm.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{OptimizerMies$new()}}
\item \href{#method-clone}{\code{OptimizerMies$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format">}\href{../../bbotk/html/Optimizer.html#method-format}{\code{bbotk::Optimizer$format()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize">}\href{../../bbotk/html/Optimizer.html#method-optimize}{\code{bbotk::Optimizer$optimize()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print">}\href{../../bbotk/html/Optimizer.html#method-print}{\code{bbotk::Optimizer$print()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Initialize the \code{OptimizerMies} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{OptimizerMies$new(
  mutator = MutatorProxy$new(),
  recombinator = RecombinatorProxy$new(),
  parent_selector = SelectorProxy$new(),
  survival_selector = SelectorProxy$new(),
  elite_selector = NULL,
  multi_fidelity = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mutator}}{(\code{\link{Mutator}})\cr
Mutation operation to perform during \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}, see there for more information. Default is \code{\link{MutatorProxy}}, which
exposes the operation as a configuration parameter of the optimizer itself.\cr
The \verb{$mutator} field will reflect this value.}

\item{\code{recombinator}}{(\code{\link{Recombinator}})\cr
Recombination operation to perform during \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}, see there for more information. Default is \code{\link{RecombinatorProxy}},
which exposes the operation as a configuration parameter of the optimizer itself. Note: The default \code{\link{RecombinatorProxy}} has \verb{$n_indivs_in} set to 2,
so to use recombination operations with more than two inputs, or to use population size of 1, it may be necessary to construct this
argument explicitly.\cr
The \verb{$recombinator} field will reflect this value.}

\item{\code{parent_selector}}{(\code{\link{Selector}})\cr
Parent selection operation to perform during \code{\link[=mies_generate_offspring]{mies_generate_offspring()}}, see there for more information. Default is \code{\link{SelectorProxy}},
which exposes the operation as a configuration parameter of the optimizer itself.\cr
The \verb{$parent_selector} field will reflect this value.}

\item{\code{survival_selector}}{(\code{\link{Selector}})\cr
Survival selection operation to use in \code{\link[=mies_survival_plus]{mies_survival_plus()}} or \code{\link[=mies_survival_comma]{mies_survival_comma()}} (depending on the \code{survival_strategy} configuration parameter),
see there for more information. Default is \code{\link{SelectorProxy}}, which exposes the operation as a configuration parameter of the optimizer itself.\cr
The \verb{$survival_selector} field will reflect this value.}

\item{\code{elite_selector}}{(\code{\link{Selector}} | \code{NULL})\cr
Elite selector used in \code{\link[=mies_survival_comma]{mies_survival_comma()}}, see there for more information. "Comma" selection is only available when this
argument is not \code{NULL}. Default \code{NULL}.\cr
The \verb{$elite_selector} field will reflect this value.}

\item{\code{multi_fidelity}}{(\code{logical(1)})\cr
Whether to enable multi-fidelity optimization. When this is \code{TRUE}, then the \code{\link[bbotk:OptimInstance]{OptimInstance}} being optimized must
contain a \code{\link[paradox:Param]{Param}} tagged \code{"budget"}, which is then used as the "budget" search space component, determined by
\code{fidelity_schedule} instead of by the \code{\link{MiesOperator}}s themselves. For multi-fidelity optimization, the \code{fidelity_schedule},
\code{fidelity_generation_lookahead}, \code{fidelity_current_gen_only}, and \code{fidelity_monotonic} configuration parameters must be given to determine
multi-fidelity behaviour. (While the initial values for most of these are probably good for most cases in which more budget implies
higher fidelity, the \code{fidelity_schedule} configuration parameter should be adjusted in most cases). Default is \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{OptimizerMies$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
\section{Super classes}{
\code{\link[mlr3tuning:Tuner]{mlr3tuning::Tuner}} -> \code{\link[mlr3tuning:TunerFromOptimizer]{mlr3tuning::TunerFromOptimizer}} -> \code{TunerMies}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{TunerMies$new()}}
\item \href{#method-clone}{\code{TunerMies$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="format">}\href{../../mlr3tuning/html/Tuner.html#method-format}{\code{mlr3tuning::Tuner$format()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="print">}\href{../../mlr3tuning/html/Tuner.html#method-print}{\code{mlr3tuning::Tuner$print()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="mlr3tuning" data-topic="TunerFromOptimizer" data-id="optimize">}\href{../../mlr3tuning/html/TunerFromOptimizer.html#method-optimize}{\code{mlr3tuning::TunerFromOptimizer$optimize()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Initialize the \code{TunerMies} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TunerMies$new(
  mutator = MutatorProxy$new(),
  recombinator = RecombinatorProxy$new(),
  parent_selector = SelectorProxy$new(),
  survival_selector = SelectorProxy$new(),
  elite_selector = NULL,
  multi_fidelity = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mutator}}{(\code{\link{Mutator}})}

\item{\code{recombinator}}{(\code{\link{Recombinator}})}

\item{\code{parent_selector}}{(\code{\link{Selector}})}

\item{\code{survival_selector}}{(\code{\link{Selector}})}

\item{\code{elite_selector}}{(\code{\link{Selector}} | \code{NULL})}

\item{\code{multi_fidelity}}{(\code{logical(1)})}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TunerMies$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}

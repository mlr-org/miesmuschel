% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TerminatorGenerationPerfReached.R
\name{mlr_terminators_genperfreached}
\alias{mlr_terminators_genperfreached}
\alias{TerminatorGenerationPerfReached}
\title{Terminator That Stops When a Generation-Wise Aggregated Value Reaches a Target}
\description{
\code{Terminator} that terminates when a value, aggregated over generations, reaches a target value.

The user-supplied \code{fitness_aggregator} function is called whenever the archive of evaluated configurations contains a new generation.
The function is supplied with the fitness values, and optionally other data, of all individuals that are alive at that point
(\code{include_previous_generations = FALSE}) or at any point (\code{include_previous_generations = TRUE}).
Its result is saved inside the \verb{$data_extra} field of the \code{Archive} object.
Termination is then signaled when the aggregated value meets or exceeds \code{level}.

The \code{\link[=mies_aggregate_single_generation]{mies_aggregate_single_generation()}} function is used, see the documentation there for the functioning of \code{fitness_aggregator}.
The \code{fitness_aggregator} functions used for termination must return a scalar value or \code{NULL}, if a generation should be ignored.
The value returned by \code{fitness_aggregator} should be increasing for better performance, even if the underlying objective is being minimized.
}
\section{Multi-Fidelity Optimization}{


Multi-fidelity optimization can introduce a few edge-cases because the individuals inside the generation(s) being aggregated may have
been evaluated with different fidelity values, which can give biased results.

When \code{\link{OptimizerMies}} is constructed with \code{multi_fidelity} set to \code{TRUE}, it typically evaluates some configurations multiple times,
at first with a lower fidelity, followed by an evaluation at "full" fidelity.
\code{fitness_aggregator} will only be called for generations containing entirely full-fidelity-evaluations will be aggregated.

This is achieved by caching aggregated fitness values in the \verb{$data_extra} field of the \code{Archive} and only ever calling
\code{fitness_aggregator} for a generation that does not have a cached value. Since \code{\link[=mies_step_fidelity]{mies_step_fidelity()}} will
count low-fidelity evaluations as part of the "previous" generation, \code{fitness_aggregator} will not see them.
Note, however that if \code{fitness_aggregator} returns \code{NULL}, it will be called again should a second evaluation occur in the same generation,
since \code{NULL} is not cached and instead treated as absent.

It is possible for \code{fitness_aggregator} to see fitness values that were evaluated with different fidelities when using \code{\link{OptimizerMies}},
and
\enumerate{
\item \code{fidelity_monotonic} is set to \code{TRUE} and fidelity decreases (unlikely setup), or
\item if \code{fidelity_current_gen_only} is set to \code{FALSE} (advanced usage), or
\item The value returned by the \code{fidelity} configuration parameter (not \code{fidelity_offspring}) changes over the course of optimization and
\code{include_previous_generations} of \code{TerminatorGenerationStagnation} is set to \code{TRUE}.
}

(1) and (2) only need consideration in advanced scenarios, but (3) may be a common, e.g. when doing multi-fidelity optimization
and stopping on reaching an overall dominated hypervolume target. In this case, it may be necessary to inspect the \code{budget} value given to \code{fitness_aggregator}
and to remove all individuals evaluated with a different than the current fidelity.

When using a custom-written optimization loop, case (1) relates to \code{fidelity_monotonic} argument of \code{\link[=mies_step_fidelity]{mies_step_fidelity()}} and \code{\link[=mies_init_population]{mies_init_population()}},
and case (2) relates to the \code{current_gen_only} argument of \code{\link[=mies_step_fidelity]{mies_step_fidelity()}} and the \code{fidelity_new_individuals_only} argument of \code{\link[=mies_init_population]{mies_init_population()}}.
Case (3) relates to changing the fidelity given to \code{\link[=mies_step_fidelity]{mies_step_fidelity()}} if that function is used, or to changing the fidelity given to \code{\link[=mies_evaluate_offspring]{mies_evaluate_offspring()}} if
\code{\link[=mies_step_fidelity]{mies_step_fidelity()}} is not used.
}

\section{Dictionary}{

This \code{Terminator} can be created with the short access form \code{trm()} (\code{trms()} to get a list),
or through the \link[mlr3misc:Dictionary]{dictionary} \code{mlr_terminators} in the following way:

\if{html}{\out{<div class="sourceCode">}}\preformatted{# preferred
trm("genperfreached")
trms("genperfreached")  # takes vector IDs, returns list of Terminators

# long form
mlr_terminators$get("genperfreached")
}\if{html}{\out{</div>}}
}

\section{Configuration Parameters}{

\itemize{
\item \code{fitness_aggregator} :: \code{function}\cr
Aggregation function, called with information about alive individuals of each generation.
This argument is passed to \code{\link[=mies_aggregate_single_generation]{mies_aggregate_single_generation()}}, see there for more details.
The aggregated values returned by \code{fitness_aggregator} should be maximized, so a larger value must be returned to indicate improvement in a generation,
even if an underlying objective is being minimized. The return value must be a scalar \code{numeric(1)}.
\item \code{include_previous_generations} :: \code{logical(1)}\cr
Whether to aggregate over all individuals that were evaluated (\code{TRUE}), or only the individuals alive in the current generation (\code{FALSE}).
If multi-fidelity optimization is being performed and individuals were re-evaluated with a different fidelity, their \code{x_id} will be the same and only
the last fidelity-reevaluation will be given to \code{fitness_aggregator}. However, individuals from different generations may still have been evaluated
with different fidelity and it may be necessary to inspect the \code{budget} value given to \code{fitness_aggregator} if \code{include_previous_generations} is \code{TRUE} in a
multi-fidelity-setting. See the "Multi-Fidelity Optimization" section for more.
\item \code{level} :: \code{numeric(1)}\cr
Minimum aggregated value for which to terminate.
}
}

\examples{
set.seed(1)
library("bbotk")
lgr::threshold("warn")

# Terminate when hypervolume with nadir `c(0, 0, ...)`
# does not improve for 3 generations by at least 0.1:
tg <- trm("genperfreached",
  fitness_aggregator = function(fitnesses) domhv(fitnesses),
  include_previous_generations = TRUE,
  level = 1
)

set.seed(1)
objective <- ObjectiveRFun$new(
  fun = function(xs) {
    list(y1 = xs$x1, y2 = xs$x2)
  },
  domain = ps(x1 = p_dbl(0, 1), x2 = p_dbl(-1, 0)),
  codomain = ps(y1 = p_dbl(0, 1, tags = "maximize"),
    y2 = p_dbl(-1, 0, tags = "minimize"))
)

oi <- OptimInstanceMultiCrit$new(objective, terminator = tg)

op <- opt("mies",
  lambda = 4, mu = 4,
  mutator = mut("gauss", sdev = 0.1),
  recombinator = rec("xounif"),
  parent_selector = sel("random"),
  survival_selector = sel("best", scl("hypervolume"))
)

op$optimize(oi)

# the observed aggregated values:
oi$archive$data_extra$TerminatorGenerationPerfReached

# ... or as calculated by mies_generation_apply
mies_generation_apply(oi$archive, function(fitnesses) {
  domhv(fitnesses)
}, include_previous_generations = TRUE)
#' @export
}
\section{Super class}{
\code{bbotk::Terminator} -> \code{TerminatorGenerationPerfReached}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-TerminatorGenerationPerfReached-new}{\code{TerminatorGenerationPerfReached$new()}}
\item \href{#method-TerminatorGenerationPerfReached-is_terminated}{\code{TerminatorGenerationPerfReached$is_terminated()}}
\item \href{#method-TerminatorGenerationPerfReached-clone}{\code{TerminatorGenerationPerfReached$clone()}}
}
}
\if{html}{\out{
<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TerminatorGenerationPerfReached-new"></a>}}
\if{latex}{\out{\hypertarget{method-TerminatorGenerationPerfReached-new}{}}}
\subsection{Method \code{new()}}{
Initialize the \code{TerminatorGenerationPerfReached} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TerminatorGenerationPerfReached$new()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TerminatorGenerationPerfReached-is_terminated"></a>}}
\if{latex}{\out{\hypertarget{method-TerminatorGenerationPerfReached-is_terminated}{}}}
\subsection{Method \code{is_terminated()}}{
Is \code{TRUE} if when the termination criterion is matched, \code{FALSE} otherwise.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TerminatorGenerationPerfReached$is_terminated(archive)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{archive}}{\code{Archive}
Archive to check.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{logical(1)}: Whether to terminate.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-TerminatorGenerationPerfReached-clone"></a>}}
\if{latex}{\out{\hypertarget{method-TerminatorGenerationPerfReached-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{TerminatorGenerationPerfReached$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}

#' @title Selector-Combination that Selects According to Two Selectors
#'
#' @include Selector.R
#'
#' @name dict_selector_maybe
#'
#' @description
#' [`Selector`] that wraps two other [`Selector`]s given during construction and uses both for selection proportionally.
#' Each of the resulting `n_select` individuals is chosen either from `$selector`, or from `$selector_not`.
#'
#' This makes it possible to implement selection methods such as random interleaving, where only a fraction of `p`
#' individuals were selected by a criterion, while the others are taken randomly.
#'
#' @section Algorithm:
#' To perform selection, `n_selector_in` rows of `values` are given to `$selector`, and the remaining
#' `nrow(values) - n_selector_in` rows are given to `$selector_not`. Both selectors are used to generate
#' a subset of selected individuals: `$selector` generates `n_selector_out` individuals, and `$selector_not` generates
#' `n_select - n_selector_out` individuals.
#'
#' `n_selector_in` is either set to
#' `round(nrow(values) * p_in)` when `proportion_in` is `"exact"`, or to `rbinom(1, nrow(values), p_in)` when `proportion_in` is `"random"`.
#'
#' `n_selector_out` is set to `round(n_select * p_out)` when `proportion_out` is `"exact"`,
#' `rbinom(1, n_select, p_out)` when `proportion_out` is `"random"`, or, when `proportion_out` is `"oddsequal"`, to
#' `round(n_select / (1 + ((nrow(values) - n_selector_in) * p_in * (1 - p_out)) / (n_selector_in * p_out * (1 - p_in))))`.
#' The last option gives a value close to `n_select * p_out` when `n_selector_in` is close to `nrow(values) * p_in`, but keeps the proportion
#' `n_selector_out / p_out * (1 - p_out) / (n_select - n_selector_out)` equal to `n_selector_in / p_in * (1 - p_in) / (nrow(values) - n_selector_in)`
#' (up to rounding).
#'
#' When `p_in` is exactly 1 or exactly 0, and `p_out` is not equal to `p_in`, then an error is given.
#'
#' If `nrow(values)` is 1, then this individuum is returned and `$selector` / `$selector_not` are not called.
#'
#' If `try_unique` is `TRUE`, then `n_selector_out` is set to at most `n_selector_in` and at least `n_select - nrow(values) + n_selector_in`,
#' and an error is generated when `nrow(values)` is less than `n_select`.
#'
#' If `try_unique` is `FALSE` and `n_selector_in` is either 0 or `nrow(values)`, and `n_selector_out` is not equal to 0 or `n_select`, respectively, then
#' `n_selector_in` is increased / decreased by 1 to give `$selector_not` / `$selector` at least one individuum to choose from.
#'
#' If `n_selector_out` is `n_select` or 0, then only `$selector` / `$selector_not` is executed, respectively; possibly with a subset
#' of `values` if `n_selector_in` differs from `nrow(values)` / 0.
#'
#' @section Configuration Parameters:
#' This operator has the configuration parameters of the [`Selector`]s that it wraps: The configuration parameters of the operator given to the `selector` construction argument
#' are prefixed with `"maybe."`, the configuration parameters of the operator given to the `selector_not` construction argument are prefixed with `"maybe_not."`.
#'
#' Additional configuration parameters:
#' * `p_in` :: `numeric(1)` \cr
#'   Probability per individual (when `random_choise` is `TRUE`), or fraction of individuals (when `random_choice` is `FALSE`),
#'   that are given to `$selector` instead of `$selector_not`. This may be overriden when `try_unique` is `TRUE`, in which
#'   case at least as many rows are given to `$selector` and `$selector_not` as they are generating output values respectively.
#'   When this is exactly 1 or exactly 0, then `p_out` must be equal to `p_in`.
#'   Must be set by the user.
#' * `p_out` :: `numeric(1)` \cr
#'   Probability per output value (when `random_choise` is `TRUE`), or fraction of output values (when `random_choice` is `FALSE`),
#'   that are generated by `$selector` instead of `$selector_not`. When this values is not given, it defaults to `p_in`.
#' * `shuffle_input` :: `logical(1)` \cr
#'   Whether to distribute input values randomly to `$selector` / `$selector_not`. If `FALSE`, then the first part of `values`
#'   is given to `$selector`. This only randomizes *which* lines of `values` are given to `$selector` / `$selector_not`, but it
#'   does not necessarily reorder the lines of values given to each. In particular, if `p_out` is 0 or 1, then no shuffling takes place. Initialized to `TRUE`.
#' * `proportion_in` :: `character(1)` \cr
#'   When set to `"random"`, sample the number of individuals given to `$selector` according to `rbinom(1, nrow(values), p_in)`.
#'   When set to `"exact"`, give `$selector` `round(nrow(values) * p_in)` individuals. Initialized to `"exact"`.
#' * `proportion_out` :: `character(1)` \cr
#'   When set to `"random"`, sample the number of individuals generated by `$selector` according to `rbinom(1, n_select, p_out)`.
#'   When set to `"exact"`, have `$selector` generate `round(n_select * p_out)` individuals.
#'   When set to `"oddsequal"`, the number of individuals generated by `$selector` is set to
#'   `round(n_select / (1 + ((nrow(values) - n_selector_in) * p_in * (1 - p_out)) / (n_selector_in * p_out * (1 - p_in))))`.
#'   Initialized to `"oddsequal"`.
#' * `try_unique` :: `logical(1)`\cr
#'   Whether to give at least as many rows of `values` to each of `$selector` and `$selector_not` as they are generating output
#'   values. This should be set to `TRUE` whenever `SelectorMaybe` is used to select unique values, and can be set to
#'   `FALSE` when selecting values multiple times is acceptable. When this is `TRUE`, then having `n_select > nrow(values)`
#'   generates an error. Initialized to `TRUE`.
#'
#' @templateVar id maybe
#' @templateVar additional , \<selector\> \[, \<selector_not\>\]
#' @template autoinfo_prepare_ftr
#'
#' @section Supported Operand Types:
#'
#' Supported [`Param`][paradox::Param] classes are the set intersection of supported classes of `selector` and `selector_not`.
#'
#' @template autoinfo_dict
#'
#' @family selectors
#' @family selector wrappers
#' @examples
#' # TODO
#' @export
SelectorMaybe = R6Class("SelectorMaybe",
  inherit = Selector,
  public = list(
    #' @description
    #' Initialize the `SelectorMaybe` object.
    #' @param selector ([`Selector`])\cr
    #'   [`Selector`] to wrap. This operator gets run with probability / fraction `p_in` (Configuration parameter).\cr
    #'   The constructed object gets a *clone* of this argument.
    #'   The `$selector` field will reflect this value.
    #' @param selector_not ([`Selector`])\cr
    #'   Another [`Selector`] to wrap. This operator runs when `selector` is not chosen. By
    #'   default, this is [`SelectorRandom`], i.e. selecting randomly.\cr
    #'   The constructed object gets a *clone* of this argument.
    #'   The `$selector_not` field will reflect this value.
    initialize = function(selector, selector_not = SelectorRandom$new()) {
      private$.wrapped = assert_r6(selector, "Selector")$clone(deep = TRUE)
      private$.wrapped_not = assert_r6(selector_not, "Selector")$clone(deep = TRUE)

      private$.wrapped$param_set$set_id = "maybe"
      private$.wrapped_not$param_set$set_id = "maybe_not"
      private$.maybe_param_set = ps(
        p_in = p_dbl(0, 1, tags = "required"),
        p_out = p_dbl(0, 1),
        shuffle_input = p_lgl(tags = "required"),
        proportion_in = p_fct(c("random", "exact"), tags = "required"),
        proportion_out = p_fct(c("random", "exact", "oddsequal"), tags = "required"),
        try_unique = p_lgl(tags = "required")
      )
      private$.maybe_param_set$values = list(shuffle_input = TRUE,
        proportion_in = "exact", proportion_out = "oddsequal", try_unique = TRUE)
      super$initialize(param_classes = intersect(selector$param_classes, selector_not$param_classes),
        param_set = alist(private$.maybe_param_set, private$.wrapped$param_set, private$.wrapped_not$param_set),
        supported = intersect(selector$supported, selector_not$supported),
        packages = c("stats", selector$packages, selector_not$packages), dict_entry = "maybe",
        own_param_set = quote(private$.maybe_param_set))
    },
    #' @description
    #' See [`MiesOperator`] method. Primes both this operator, as well as the wrapped operators
    #' given to `selector` and `selector_not` during construction.
    #' @param param_set ([`ParamSet`][paradox::ParamSet])\cr
    #'   Passed to [`MiesOperator`]`$prime()`.
    #' @return [invisible] `self`.
    prime = function(param_set) {
      private$.wrapped$prime(param_set)
      private$.wrapped_not$prime(param_set)
      super$prime(param_set)
      invisible(self)
    }
  ),
  active = list(
    #' @field selector ([`Selector`])\cr
    #' [`Selector`] being wrapped. This operator gets run with probability / proportion `p_in` and generates
    #' output with probability / proportion `p_out` (configuration parameters).
    selector = function(val) {
      if (!missing(val)) stop("mutator is read-only.")
      private$.wrapped
    },
    #' @field selector_not ([`Selector`])\cr
    #' Alternative [`Selector`] being wrapped. This operator gets run with probability / proportion `1 - p_in`
    #' and generates output with probability / proportion `1 - p_out` (configuration parameters).
    selector_not = function(val) {
      if (!missing(val)) stop("mutator_not is read-only.")
      private$.wrapped_not
    }
  ),
  private = list(
    .select = function(values, fitnesses, n_select) {
      params = private$.maybe_param_set$get_values()
      params$p_out = params$p_out %??% params$p_in

      if (params$p_in %in% c(0, 1) && params$p_out != params$p_in) {
        stopf("When p_in is %s, then p_out must also be %s, but it is %s instead.", params$p_in, params$p_in, params$p_out)
      }

      if (params$try_unique && nrow(values) < n_select) {
        stopf("try_unique is TRUE, but nrow(values) (which is %s) is less than n_select (which is %s).", nrow(values), n_select)
      }

      if (nrow(values) == 1) return(rep(1L, n_select))

      n_selector_in = switch(params$proportion_in,
        random = stats::rbinom(1, nrow(values), params$p_in),
        excact = round(nrow(values) * params$p_in)
      )
      n_selector_not_in = nrow(values) - n_selector_in

      n_selector_out = switch(params$proportion_out,
        random = stats::rbinom(1, n_select, params$p_out),
        excact = round(n_select * params$p_out),
        oddsequal = {
          if (params$p_in == params$p_out) {
            # catch mostly the p_in == 0 or 1 cases.
            # If p_out were not equal to p_in in these cases we would throw an error above.
            # If they *are* equal, we would get a 0 / 0 division below.
            # Note that if p_out is 1 or 0 but p_in is not, then FP arithmetic does the
            # right thing and we get expected results, so we don't need to handle this as another case.
            round(n_selector_in * n_select / nrow(values))
          } else {
            round(n_select /
              (1 +
                (n_selector_not_in * params$p_in * (1 - params$p_out)) /
                (n_selector_in * params$p_out * (1 - params$p_in))
              )
            )
          }
        }
      )
      if (params$try_unique) {
        # make sure:
        # 1) n_selector_out >= n_selector_in
        # 2) n_select - n_selector_out >= nrow(values) - n_selector_in
        #   <=> n_selector_out <= n_select - nrow(values) + n_selector_in
        n_selector_out = min(max(n_selector_out, n_select - nrow(values) + n_selector_in), n_selector_in)
      } else if (n_selector_out %nin% c(0, n_select)) {
        n_selector_in = min(max(n_selector_in, 1), nrow(values) - 1)
      }

      # a logical vector, so we can also negate
      if (params$shuffle_input) {
        s_in = sample.int(nrow(values)) <= n_selector_in
        selector_in = which(s_in)
        selector_not_in = which(!s_in)
      } else {
        selector_in = seq_len(n_selector_in)
        selector_not_in = seq_len(nrow(values) - n_selector_in) + n_selector_in
      }

      if (selector_out == n_select) {
        selector_in[private$.wrapped$operate(values[selector_in], fitnesses[selector_in, , drop = FALSE], n_select)]
      } else if (selector_out == 0) {
        selector_not_in[private$.wrapped_not$operate(values[selector_not_in], fitnesses[selector_not_in, , drop = FALSE], n_select)]
      } else {
        # if we get here, then both operators need to work.
        c(
          selector_in[private$.wrapped$operate(values[selector_in], fitnesses[selector_in, , drop = FALSE], n_select)],
          selector_not_in[private$.wrapped_not$operate(values[selector_not_in], fitnesses[selector_not_in, , drop = FALSE], n_select)]
        )
      }
    },
    .wrapped = NULL,
    .wrapped_not = NULL,
    .maybe_param_set = NULL
  )
)
dict_selectors$add("maybe", SelectorMaybe)
